#include <bits/stdc++.h>
using namespace std;

/*------------------------------- DSU CLASS---------------------------------------*/
class DSU
{
public:
    vector<int> parent;
    vector<int> componentSize;
    int totalComponents;

    // Constructor: Initialize DSU for n elements
    DSU(int n)
    {
        parent.resize(n);
        componentSize.assign(n, 1); // Every element is its own set of size 1
        iota(parent.begin(), parent.end(), 0); // parent[i] = i
        totalComponents = n;
    }

    // Find representative of the component with path compression
    int find(int node)
    {
        if (node != parent[node])
            parent[node] = find(parent[node]);
        return parent[node];
    }

    // Union the components of u and v using union by size
    bool unite(int u, int v)
    {
        int rootU = find(u);
        int rootV = find(v);

        if (rootU == rootV)
            return false;

        // Attach smaller component under the larger one
        if (componentSize[rootU] >= componentSize[rootV])
        {
            parent[rootV] = rootU;
            componentSize[rootU] += componentSize[rootV];
        }
        else
        {
            parent[rootU] = rootV;
            componentSize[rootV] += componentSize[rootU];
        }

        totalComponents--;
        return true;
    }

    // Check if u and v are in the same component
    bool sameComponent(int u, int v)
    {
        return find(u) == find(v);
    }

    // Return the size of the component containing u
    int getSize(int u)
    {
        return componentSize[find(u)];
    }

    // Return the current number of disjoint sets
    int getComponentCount()
    {
        return totalComponents;
    }
};

/*--------------------------------------------------------------------------------------*/

class Solution
{
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        int n = graph.size();
        DSU dsu(n);

        // Union all directly connected nodes
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i != j && graph[i][j] == 1)
                {
                    dsu.unite(i, j);
                }
            }
        }

        vector<int> infectedCount(n, 0); // infectedCount[root] = number of infected in this component
        vector<int> componentSize(n, 0); // componentSize[root] = size of the component

        // Sort to ensure smallest index returned in tie case
        sort(initial.begin(), initial.end());

        for (int patient : initial)
        {
            int root = dsu.find(patient);
            infectedCount[root]++; // Count infected nodes per component
        }

        for (int i = 0; i < n; i++)
        {
            int root = dsu.find(i);
            componentSize[root]++; // Count total nodes per component
        }

        int resultNode = initial[0];
        int maxSaved = 0;

        for (int patient : initial)
        {
            int root = dsu.find(patient);

            // Only consider components with exactly one infected node
            if (infectedCount[root] == 1 && componentSize[root] > maxSaved)
            {
                maxSaved = componentSize[root];
                resultNode = patient;
            }
        }

        return resultNode;
    }
};

/*
Approach:
1. Use Union Find to group all connected nodes into components.
2. Track size of each component and how many initially infected nodes each component has.
3. Only consider components with exactly one infected node and select the one
   with the largest size (more people saved if you remove this node).
4. In case of a tie, return the node with the smallest index.

Time Complexity: O(N^2 + N log N)
- O(N^2) to build connections from adjacency matrix
- O(N log N) to sort initial list

Space Complexity: O(N)
*/
